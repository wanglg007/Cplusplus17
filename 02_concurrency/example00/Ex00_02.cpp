//(0.2)当线程仍然访问局部变量时返回的函数
#include <thread>

void do_something(int &i) {
    ++i;
}

struct func {
    int &i;

    func(int &i_) : i(i_) {
    }

    void operator()() {
        for (unsigned j = 0; j < 100000; ++j) {
            do_something(i);                //(1)对悬空引用可能的访问
        }
    }
};

void oops() {
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread my_thread(my_func);
    my_thread.detach();                     //(2)不等待线程结束
    //(3)新线程可能还在运行
}

int main() {
    oops();
}

/**
 * 如果不等待线程，就必须保证线程结束之前可访问的数据得有效性。单线程代码中，若对象销毁之后再去访问会产生未定义行为。不过线程的生命周
 * 期增加了该问题发生的几率。这种情况很可能发生在线程还没结束时，函数已经退出。此时线程函数还持有函数局部变量的指针或引用。
 *
 * 该示例已经决定不等待线程结束(使用了detach()②)，所以当oops()函数执行完成时③，新线程中的函数可能还在运行。如果线程还在运行，它就会
 * 调用do_something(i)函数①，这时就会访问已经销毁的变量。
 *
 * 处理该情况的常规方法：使线程函数的功能齐全，并将数据复制到线程中，而非复制到共享数据中。如果使用一个可调用的对象作为线程函数，该对象
 * 就会复制到线程中，而后原始对象会立即销毁。使用一个能访问局部变量的函数去创建线程是一个糟糕的主意(除非十分确定线程会在函数完成前结束)。
 * 此外，可以通过加入的方式来确保线程在函数完成前结束。
 */
















